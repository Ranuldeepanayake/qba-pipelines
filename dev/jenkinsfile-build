#!/usr/bin/env groovy

//Global variables
def CODE_REPOSITORY_URL = "git@github.com:Ranuldeepanayake/$JOB_BASE_NAME" + ".git"
def SELECTOR_PACKAGE_JSON = ['qba-back-end', 'qba-front-end']
def VERSION_NUM
def BUILD_TIMESTAMP
def VERSION_FILE
def ARTIFACT_REPOSITORY_URL = 'public.ecr.aws/l4a5c1v5'
def ARTIFACT_REPOSITORY_USERNAME = 'AWS'
def ARTIFACT_REPOSITORY_REGION = 'us-east-1'
def IMAGE_TAG_PREFIX = "$ARTIFACT_REPOSITORY_URL/qba/$JOB_BASE_NAME"

def DEPLOYMENT_REPOSITORY_URL = 'git@github.com:Ranuldeepanayake/qba-helm.git'
def DEPLOYMENT_BRANCH = 'main'
def DEPLOYMENT_COMMIT_EMAIL = 'ranuldeepanayake@outlook.com'
def DEPLOYMENT_COMMIT_USERNAME = 'Ranul'

//Input parameter variables.
//INPUT_GIT_BRANCH
//INPUT_ACTION

pipeline {

  agent {
    label "JENKINS-WORKER-1"
  }

  parameters {
    //Form element to select the action.  
    choice choices: ['Build', 'Build-and-Deploy', 'Deploy'], description: 'Select action', name: 'INPUT_ACTION'

    //Form element to select the git branch.
    listGitBranches branchFilter: '.*', credentialsId: 'Github-SSH-Key', defaultValue: 'develop', 
    description: 'Select the required branch', listSize: '5', name: 'INPUT_GIT_BRANCH', quickFilterEnabled: true, 
    remoteURL: CODE_REPOSITORY_URL, selectedValue: 'NONE', sortMode: 'DESCENDING', tagFilter: '*', type: 'PT_BRANCH'
  } 

  options {
    skipDefaultCheckout()
  }

  stages {   
    stage("Pipeline start"){
      steps {
        script{
          //Clean the workspace.
          cleanWs()

          sh "echo Pipeline started"
          sh "echo Selected action: $INPUT_ACTION"
          sh "echo Selected branch: $INPUT_GIT_BRANCH"

        }
      }
    }

    //Checkout the source code.
    stage("Repository checkout"){
      steps {
        dir("app-repo"){
          checkout scmGit(
              branches: [[name: INPUT_GIT_BRANCH]], userRemoteConfigs: [[credentialsId: 'Github-SSH-Key', 
              url: CODE_REPOSITORY_URL]]
          )
        }
      }
    }

    //Get the current version number.
    stage("Read the version number"){
      // when {
      //     expression {
      //       return SELECTOR_PACKAGE_JSON.contains(env.JOB_BASE_NAME)
      //     }
      // }

      steps{
        script{
          //Handle multiple version file types.
          if (SELECTOR_PACKAGE_JSON.contains(env.JOB_BASE_NAME)){
            VERSION_FILE = "app-repo/package.json"
            //Read the version file.
            VERSION_NUM = sh(returnStdout: true, script: "jq -r .version $VERSION_FILE | tr -d '\n' ")
            sh "echo Current version: $VERSION_NUM"
          }

          //Check for inconsistencies in the version number and pass or fail the job.
          //The version number in the release branch should only have three number segments. The patch version must be 0.
          if (VERSION_NUM ==~ /([0-9]+\.[0-9]+\.[0]){1,1}/) {
            sh "echo Version number is consistent with the format"
          }else {
            sh "echo Version number is inconsistent with the format. Exiting!"
            exit 1
          }
        }
      }
    }

    //Build the image with docker.
    stage("Docker build"){
      when {
        anyOf {
          expression {INPUT_ACTION == 'Build'}
          expression {INPUT_ACTION == 'Build-and-Deploy'}
        }
      }

      steps {
        script {
            //Create the timestamp to be appended to the image.
            BUILD_TIMESTAMP = new Date()
            BUILD_TIMESTAMP = BUILD_TIMESTAMP.format("YYYYMMddHHmm", TimeZone.getTimeZone('IST'))
            sh "echo Build timestamp: $BUILD_TIMESTAMP"

            sh "cd ./app-repo; docker build -f dockerfile -t $IMAGE_TAG_PREFIX:$VERSION_NUM-SNAPSHOT-$BUILD_TIMESTAMP ."
        }
      }
    }

    //Push the built image to the artifact repository.
    stage("Artifact push"){
      when {
        anyOf {
          expression {INPUT_ACTION == 'Build'}
          expression {INPUT_ACTION == 'Build-and-Deploy'}
        }
      }

      steps {
        script{
          withCredentials([aws(accessKeyVariable: 'AWS_ACCESS_KEY_ID', credentialsId: 'jenkins-aws-key-1', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            sh "aws ecr-public get-login-password --region $ARTIFACT_REPOSITORY_REGION | docker login --username $ARTIFACT_REPOSITORY_USERNAME \
            --password-stdin $ARTIFACT_REPOSITORY_URL"
            sh "docker push $IMAGE_TAG_PREFIX:$VERSION_NUM-SNAPSHOT-$BUILD_TIMESTAMP"
          }
        }
      }
    }
    
    //Pull the deployment repo to be updated with new values.
    stage("Pull deployment repo"){
      when {
        anyOf {
          expression {INPUT_ACTION == 'Build-and-Deploy'}
          expression {INPUT_ACTION == 'Deploy'}
        }
      }

      steps {
        dir('deployment-repo'){
            checkout scmGit(
                branches: [[name: DEPLOYMENT_BRANCH]], userRemoteConfigs: [[credentialsId: 'Github-SSH-Key', 
                url: DEPLOYMENT_REPOSITORY_URL]]
            )
        }
      }
    }

    //Deflate helm template.
    stage("Deflate helm templates for Kustomize in ArgoCD"){
      when {
        anyOf {
          expression {INPUT_ACTION == 'Build-and-Deploy'}
          expression {INPUT_ACTION == 'Deploy'}
        }
      }

      steps {
        script {
          dir("$WORKSPACE/deployment-repo"){
            //Commit and push.
            sh '''
              cd qba
              helm template . > rendered.yaml
              ls -la | grep rendered.yaml
            '''
          }
        }
      }
    }

    //Copy the .env file from the app repo to the deployment repo.
    stage("Copy the .env file from the app repo to the deployment repo"){
      when {
        anyOf {
          expression {INPUT_ACTION == 'Build-and-Deploy'}
          expression {INPUT_ACTION == 'Deploy'}
        }
      }

      steps {
        sshagent(['Github-SSH-Key']) {
          script {
            sh "pwd"
            sh "ls -la"

            dir("$WORKSPACE/app-repo"){
              sh "pwd"
              sh "ls -la"
              
              //sh "git checkout $PARENT_BRANCH"
              sh "git config --get remote.origin.url"

              //Print the variable file in both repos.
              sh "cat .env/.env-dev"
              //sh "cat $WORKSPACE/deployment-repo/.env"
            }

            dir("$WORKSPACE/deployment-repo"){
              //Commit and push.
              sh "git config --get remote.origin.url"

              sh "git checkout $DEPLOYMENT_BRANCH"

              //Copy the env file to the deployment repo.
              sh "cp $WORKSPACE/app-repo/.env/.env-dev qba/files/$JOB_BASE_NAME\\.env"
              sh "pwd"
              sh "ls -la"
              
              //Configure the username and email for commits.
              sh "git config user.email $DEPLOYMENT_COMMIT_EMAIL"
              sh "git config user.name $DEPLOYMENT_COMMIT_USERNAME"

              sh "git add ."
              sh "git commit --allow-empty -m 'Environment file in the deployment repo replaced with the file in the app repo' "
              sh "git push origin $PARENT_BRANCH"
            }
          }
        }  
      }
    } 

  } 
}


